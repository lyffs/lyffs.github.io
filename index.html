<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/goexec/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/09/goexec/" itemprop="url">goexec</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-09T22:30:20+08:00">
                2020-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Go-program-execute-process"><a href="#Go-program-execute-process" class="headerlink" title="Go program execute process"></a>Go program execute process</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><pre><code>本文从Golang的小程序反汇编得到汇编代码，从中分析Golang程序执行过程。

Golang 程序

`
    package main
    import &quot;fmt&quot;

    func main() {
        ch1 := make(chan int)
        go func() {
            fmt.Println(&quot;hello&quot;)
            ch1 &lt;- 1
    }()
    &lt;-ch1
    }

`
先通过golang build -gcflags &quot;-N -l&quot; （禁止内联）生成可执行程序，然后通过GDB跟踪。</code></pre><h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><pre><code>//入口
1.TEXT runtime·rt0_go(SB),NOSPLIT,$0
    get_tls(BX)
           LEAQ    runtime·g0(SB), CX
           MOVQ    CX, g(BX)
        LEAQ    runtime·m0(SB), AX

    // save m-&gt;g0 = g0
        MOVQ    CX, m_g0(AX)
           // save m0 to g0-&gt;m
        MOVQ    AX, g_m(CX)

    CALL    runtime·check(SB)
    MOVL    16(SP), AX              // copy argc
        MOVL    AX, 0(SP)
           MOVQ    24(SP), AX              // copy argv
           MOVQ    AX, 8(SP)
           CALL    runtime·args(SB)
        CALL    runtime·osinit(SB)
        CALL    runtime·schedinit(SB)

    // create a new goroutine to start program
        MOVQ    $runtime·mainPC(SB), AX         // entry
           PUSHQ   AX   
        PUSHQ   $0                      // arg size
           CALL    runtime·newproc(SB)
        POPQ    AX   
        POPQ    AX   

          // start this M
    // mstart shou never return
        CALL    runtime·mstart(SB)


//类型测试
2 runtime.check()

//
3 runtime.args()

//
4 runtime.osinit()
    ncpu = getproccount() //获取CPU计算
    physHugePageSize = getHugePageSize() //获取大页大小

//The bootstrap sequence is:
// call osinit
// call schedinit
// make &amp; queue new G
// call runtime.mstart

5 runtime.schedinit()
    _g_ := getg() //获取当前g的指针
    sched.maxmcount = 10000 //m的最大计数为1w
    tracebackinit()
    moduledateverify()
    stackinit() //初始化stack pool
    mallocinit() //内存管理初始化，主要是初始花mheap_，初始化arena。定义不同内存状态的申请
    mcommoninit(_g_.m) //m公共初始化
    cpuinit() //cpu初始化
    alginit() //算法初始化
    modulesinit() //
    typelinksinit()
    itabsinit()

    msigsave(_g_.m)

    goargs()
    goenvs()
    parsedebuggvars() //解析debug变量
    procresize(procs) //write barrier needs a P    

6 runtime.mallocinit()
    mheap_.init() //堆初始化
    _g_ := getg()
    _g_.m.mcache = allocmacache()

7 runtime.mcommoninit()
    mpreinit(mp) //m.gsignal初始化，其中新建g，同时g的stack需要申请。从系统内存申请，或者从stackpool申请，或者从heap（mheap_）申请。

8 runtime.procresize(nproc int32) *p
    // initialize new P&apos;s
    for i := old; i &lt; nprocs; i++ {
        pp := allp[i]
        if pp == nil {
            pp = new(p)
        }

        pp.init(i) //设置pp的状态为:_Pgcstop,pp.mcache = getg().m.mcache //或者pp.mcache = allocmcache()
        atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))
    }

9 runtime.main()
    lockOSThread()        
    if g.m != &amp;m0 {
        throw(&quot;runtime.main not on m0&quot;)
    } //当前工作线程必须是m0    

    doInit(&amp;runtime_inittask) //必须要在defer之前

    gcenable() //开启gc，启动bgsweep() bgscavenge协程

    doInit(&amp;main_inittask)
    unlockOSThread()

    fn := main_main // make an indirect call, as the linker doesn&apos;t know the address of the main package when laying down the runtime
    fn()

    if atomic.Load(&amp;panicking) != 0 {
        gopark(nil, nil, waitReasonPanicWait, traceEvGoStop, 1)
    }

    exit(0)

10 runtime.gcenable() 
    c := make(chan int, 2)
    go bgsweep(c)
    go bgscavenge(c)
    &lt;-c
    &lt;-c
    memstats.enablegc = true

11 func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int)
    // 将当前goroutine设置为waiting状态，并且调用unlockf函数
    // 如果unlockf返回false，goroutine恢复
    // reason解释goroutine parked的原因
    // 它显示在堆栈跟踪和堆转储中

    mp := acquirem() //获取当前goroutine关联的m
    gp := mp.curg //获取m中正在运行的goroutine
    status := readgstatus(gp) //获取gp(goroutine)的状态
    mp.waitlock = lock
    mp.waitunlock = unlockf

    gp.waitreason = reason

    mp.waittraceev = traceEv
    mp.waittraceskip = traceskip

    releasem(mp)

    // func mcall(fn func(*g))
    // mcall从g切换到g0栈调用fn(g)，其中g是发起调用的goroutine。
    // mcall将g当前的PC/SP保存在g-sched以便以后恢复。
    // 由fn决定稍后的执行，通过记录g到数据结构中，从而后面可以调用ready(g)
    // 当g被重新调度时，mcall随后返回原始goroutine g。
    // fn绝对不能返回；通常通过调用schedule结束，让m来执行其他goroutine。
    // 
    // mcall只能在g stack(非g0或者gsignal)中被调用
    //
    // 函数必须是 go:noescape(不能逃逸)，如果fn是栈分配的闭包，
    // fn将g放在运行队列中，g在fn返回之前执行。闭包在执行过程中无效。

    mcall(park_m)


12 runtime.newproc(siz int32, fn *funcval) 
    //创建一个新的协程用于运行fn
    //将fn放在g的队列中等待运行
    //编译器将go声明转换成对它的调用
    //协程stack不能split因为它猜测函数参数在fn后面有效排列，如果stack split，他们不会复制

    argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize) //获取参数地址
    gp := getg() //获取当前goroutine
    pc := getcallerpc()

    //systemstack: 
    systemstack(func() {
        newproc1(fn, (*uint8)(argp), siz, gp, pc)
    }) 


13 runtime.park_m
    // 在g0中继续暂停

    _g_ := getg()

    //将gp状态从_Grunning变更为_Gwaiting
    casgstatus(gp, _Grunning, _Gwaiting)

    //dropg 解除m与curg的联系
    dropg()

    if fn := _g_.m.waitunlockf; fn != nil {
        ok := fn(gp, _g_.m.waitlock)
        _g_.m.waitunlockf = nil
        _g_.m.waitlock = nil
        if !ok {
            casgstatus(gp, _Gwaiting, _Grunnable)
            execute(gp, true)
        }
    }

    schedule()

14 runtime.casgstatus(gp *g, oldval, newval uint32)
    // 如果设置为Gscanstatus或者从Gscanstatus状态变更，这样抛出异常。取而代之的是castogscanstatus 和casfrom_Gscanstatus
        // 如果g-&gt;atomicstatus处于Gscan状态，casgstatus将会一直循环，直到设置状态为Gscan的routine完成。

    if (oldval&amp;_Gscan != 0) || (newval&amp;_Gscan != 0) || oldval == newval {
        //throw() //在系统栈
    }    

    if oldval == _Grunning &amp;&amp; gp.gcscanvalid {
        //throw() //在系统栈
    }

    const yieldDelay = 5 * 1000

    // 如果gp-&gt;atomicstatus处于扫描状态，循环会给GC时间完成并且将状态修改为oldval
    for i := 0; !atomic.Cas(&amp;gp.atomicstatus, oldval, newval); i++ {
        if i == 0 {
            nextYield = nanotime() + yieldDelay
        }
        if nanotime() &lt; nextYield {
            for x := 0; x &lt; 10 &amp;&amp; gp.atomicstatus != oldval; x++ {
                procyield(1)
            }
        } else {
            osyield()
            nextYield = nanotime() + yieldDelay/2
        }
    }    

    if newval == _Grunning {
        gp.gcscanvalid = false
    }

15 runtime.dropg()
    // dropg将移除m和当前routine m-&gt;curg的关联
    // 通常调用者变更gp的Grunning状态然后立刻调用dropg完成该项工作
    // 调用者还负责安排gp在恰当的时间状态变更为ready重新启动。
    // 在调用dropg和稍后安排gp状态变更为ready，调用者可以做其他工作
    // 但最终应该调用schedule来重新启动这个m上面的goroutine调度。

    _g_ := getg()

     setMNoWB(&amp;_g_.m.curg.m, nil) //非写屏障设置m当前gouroutine的m为空
     setGNoWB(&amp;_g_.m.curg, nil) //非写屏障设置m当前goroutine为空

16 runtime.execute(gp *g, inheritTime bool)
    // 调度gp在当前M上运行。
    // 如果inheritTime是true，gp在当前时间片中继承保留的时间。否则它开始一个新的
    // 时间片。
    // 从不返回

    // 允许写屏障因为在几个地方获得P之后立即调用。
    _g_ := getg()
    // 将gp的状态从_Grunnable变更为_Grunning
    casgstatus(gp, _Grunnable, _Grunning)
    gp.waitsince = 0
    gp.preemt = false
    gp.stackguard0 = gp.stack.lo + _StackGuard
    if !inheritTime {
        _g_.m.p.ptr().schedtick++
    }

    _g_.m.curg = gp //将m的正在运行的goroutine变更为gp
    gp.m = _g_.m //将gp的m变更为_g_.m

    // 检查profiler是否需要打开或者关闭
    hz := sched.profilehz
    if _g_.m.profilehz != hz {
        setThreadCPUProfiler(hz)
    }

    gogo(&amp;gp.sched)

17 runtime.schedule()
    // 调用执行一轮是：寻找一个可执行的goroutine并且执行。
    _g_ := getg()

    // guintptr, muintptr, and puintptr 用来绕过写屏障
    // 当 当前P被释放时，避免写屏障特别重要。因为GC认为整个
    // 程序已经停止，一个未预期的写屏障不会与GC同步，这可能导致
    // 对象已经标记但没有入队的执行到一半的写屏障。如果在入队之前
    // GC跳过该对象并且完成，这将导致不正确的释放该对象。

    // 我们尝试当没有拥有一个正在运行的P时只使用特殊的赋值函数，但是
    // 一些特殊内存单词的更新可以穿过写屏障，而有些没有。这打破写屏障阴影检查
    // 的模式，同时令人害怕的是：拥有一个完全被GC忽视的单词要比拥有一个只忽略少量
    // 更新的单词要好。

    // 在allgs和allp 列表中 或者来自栈变量（在他们到达那些列表之前的变量申请）的Gs
    // 和Ps通过正确的指针访问总是有效的。

    // 不论来自allm还是来自freem，Ms通过正确的指针访问总是有效。不像 Gs 和 Ps，我们
    // 释放 Ms，所有没有任何东西拥有越过安全点的muintptr非常重要。

    // A guintptr持有一个goroutine的指针，但是作为绕过写屏障的uintptr类型。它用在
    // Gobuf goroutine状态和不使用P操作的调度列表中。

    // Gobuf.g goroutine指针 总是被汇编代码更新。在一小部分地方中，
    // 它是由go代码更新 -func save-，它必须被看做一个uintptr为了避免在错误的时间
    // 产生写屏障。为了取代理解在非汇编操作中产生写屏障，我们改变uintptr的类型，所以
    // 它根本不需要写屏障

    // goroutine结构被发布在allg列表中并且从不释放。它将阻止goroutine结构被回收。
    // Gobuf.g 从来不是goroutine的唯一引用。在allg上发布的goroutine最新生成。
    // Goroutine的指针同时会保留在GC不可见的地方，比如：TLS，所以我不能看到它们
    // 移动过。如果我们确实想开始移动数据到GC，我们需要从恰当的arena中申请
    // goroutine结构。用guintptr指针不让错误变得更糟糕。

    if _g_.m.lockedg != 0 {
        stoplockedm()
        execute(_g_.m.lockedg.ptr(), false)
    }

18 runtime.stoplockedm() 
    // 停止锁定到g的当前M 的执行，直到g再次执行。
    _g_ := getg()

    if _g_.m.p != 0 {
        // 调度其他M来运行这个P
        _p_ := releasep()
        handoffp(_p_)
    }

19 runtime.releasep() *p
    // 断开p与当前m的联系
    _g_ := getg()
    // 获得当前m关联的p
    _p_ := _g_.m.p.ptr()
    // 当前m的p为0
    _g_.m.p = 0
    // 当前m的mcache为nil
    _g_.m.mcache = nil
    // 相应的p的m为0
    _p_.m = 0
    // 设置p的状态为空闲
    _p_.status = _Pidle
    return _p_

20 runtime.handoffp(_p_ *p)
    // 通过系统调用或者锁定的M，挂起_p_
    // 总是不需要P运行，所以不允许写屏障。
    // handoffp 必须在findrunnable返回G并在_p_上运行的任何情况下启动M。

    if !runqempty(_p_) || sched.runqsize != 0 {

    }

21 runtime.runqempty(_p_ *p) bool 
    // runqempty报告_p_在本地运行队列中是否有Gs。
    // 假设它从不返回true

    for {
        head := atomic.Load(&amp;_p_.runqhead)
        tail := atomic.Load(&amp;_p_.runqtail)
        runnext := atomic.Loaduintptr((*uintptr)(unsafe.Pointer(&amp;_p_.runnext)))
        // p.runnext，如果非空，是一个由当前G准备的可运行的G。
        // 如果正在运行的G还有时间片，那么接着运行的应该是runnext，而不是
        // 在runq中Gs。它将继承当前时间片剩余的时间。
        // 如果一部分的goroutine被锁定为通信与等待的模式，被设置为一个单元的调度
        // 消除由于将处于准备状态的goroutine添加到队列末尾而产生（可能）很大
        // 调度延迟。

        if tail == atomic.load(&amp;_p_.runqtail) {
            return head == tail &amp;&amp; runnext == 0
        }
    }

22 runtime.startm(_p_ *p, spinning bool)
    // 调度一些M来运行P(如果需要会创建新的M)
    // 如果p为空，尝试获取一个空闲的p，如果没有空闲p怎不做任何处理。
    // 可能运行时m.p为空，所以不允许写屏障。
    // 如果设置了spinning，调用者已经增加nmspinning和startm将减少nmspinning或者在新启动的M中设置m.spinning

    lock(&amp;sched.lock)
    if _p_  == nil {
        // 尝试从空闲列表中返回p
        // sched必须被锁定
        // 可能y运行中处于STW，所以不允许写屏障。
        _p_  = pidleget() 
        if _p_ == nil {
            unlock(&amp;sched.lock)
            if spinning {

            }
            return
        }
    }

    mp := mget()
    // 尝试从空闲链表中返回m
    unlock(&amp;sched.lock)

    if mp == nil {
        var fn func()
        if spinning {
            fn = mspinning
        }
        newm(fn, _p_)
        return
    }

23 runtime.newm(fn func(), _p_ *p)    
    // 创建一个新的m，它开始于fn或者调度器的调用
    // fn 需要是静态的并且不是堆申请的闭包
    // 运行的时候m.p可能为nil，所以不允许写屏障

    mp := allocm(_p_, fn)


24 runtime.allocm(_p_ *p, fn func()) *m
    // 申请一个和任何线程无关的m
    // 如果需要的话，可以把p用作申请的上下文。
    // fn被记录为新m的m.mstartfn

    // 该函数运行写屏障即使调用者没有这样做，因为它借用了_p_
    //  
    _g_ := getg() //获取当前goroutine
    acquirem() // 禁止GC因为在sysmon中被调用
    if _g_.m.p == 0 {
        // 在函数中为了mallocs借用p
        // 把p和当前m关联起来
        // 
        acquirep(_p_)
    }

    // 释放空闲M列表。我们在某些地方做这个工作同时这可能释放我们可以使用的一个栈。
    if sched.freem != nil {
        lock(&amp;sched.lock)
        for freem := sched.freem; freem != nil; {
            if freem.freewait != 0 {
                next := freem.freelink
                freem.freelink = newList
                newList = freem
                freem = next
                continue
            }
            stackfree(freem.g0.stack)
            freem = freem.freelink
        }
        sched.freem = newList
        unlock(&amp;sched.lock)
    }

    mp := new(m)
    mp.mstartfn = fn
    mcommoninit(mp)


25 runtime.acquirep(_p_ *p)
    // 这部分的执行不允许写屏障
    // wirep是acquirep的第一步，它实际上是将当前M和_p_关联起来。
    // 所以这部分我们不允许写屏障，因为我们没有一个P。
    // 设置_g_.m.p.set(_p_)
    // _p_.m.set(_g_.m)
    wirep(_p_)    
    // 拥有P，现在允许写屏障

    // 在P从可能旧的mcache中申请之前，执行延迟的mcache刷新
    _p_.mcache.prepareForSweep()

26 runtime (c *mcache)prepareForSweep()
    // 当c已经发布，prepareForSweep会刷新c如果系统已经进入一个新的sweep(扫描)阶段
    // 这肯定发生在sweep阶段开始和第一次申请之间。

    // 另外，为了替换 我们确保每一个P在(starting the world)和分配之间的都这样做，
    // 我们可以开启allocte-black，允许申请像平常一样继续，用一个ragged barrier在
    // 扫描的开始来确保所有缓存的spans被扫描，然后禁用allocate-black。然而，出于
    // 这个目的很难避免位标记蔓延至下个GC循环。

    sg := mheap_.sweepgen
    if c.flushGen == sg {
        return
    } else if c.flushGen != sg-2 {
        throw(&quot;bad flush&quot;)
    }

    c.releaseAll()
    stackache_clear(c)
    atomic.Store(&amp;c.flushGen, mheap_.sweepgen)

27 runtime (c *mcache)releaseAll
    for i := range c.alloc {
        s := c.alloc[i]
        if s != &amp;emptymspan {
            // s非空mspan
            mheap_.central[i].mcentral.uncacheSpan(s)
            c.alloc[i] = &amp;emptymspan
        }
    }


28 runtime (c *mcentral) uncacheSpan(s *mspan)
    // 从mcache中返回span
    if s.allocCount == 0 {
        throw(&quot;uncaching span but s.allocCount == 0&quot;)
    }

    sg := mheap_.sweepgen
    // 
    stale := s.sweepgen == sg+1
    if stale {
        // 在标记开始之前，span已经缓存，扫描它是我们的责任。
        // 设置sweepgen来指明它没有缓存但是需要标记，但是不能从
        // 这申请。sweep将设置s.sweepgen来指明s正在扫描
        atomic.Store(&amp;s.sweepgen, sg-1)
    } else{
        // 指明s不再需要标记 
        atomic.Store(&amp;s.sweepgen, sg)
    }

    n := int(s.nelems) - int(s.allocCount)
    if n &gt; 0 {
        // cacheSpan更新alloc，猜想s上面的所有对象都被申请。调整为任何没有
        // 在潜在的标记span之前 我们必须做这个。
        atomic.Xadd64(&amp;c.nmalloc, -int64(n))
        lock(&amp;c.lock)
        c.empty.remove(s)
        c.nonempty.insert(s)
        if !stale {
            // mCentral_CacheSpan 保守的计算heap_live中未分配的槽位，撤销这个
            // 如果标记前span已经缓存，接着heap_live完全是重新计算的，因为缓存了缓存了这个span，所以我们对于陈旧的
            // span作这样的操作。
            // 
            atomic.Xadd64(&amp;memstat.heap_live, -int64(n)*int64(s.elemsize))
        }
        unlock(&amp;c.lock)
    }

    if stale {
        // 现在s正在正确的mcentral列表中，我们可以标记它。
        s.sweep(false)
    }

29 runtime.mspan
    //go:notinheap

    // 链表中下一个mspan，如果没有为nil
    next *mspan
    // 链表中前一个mspan，如果没有为nil
    prev *mspan
    // 用作debug，TODO: Remove
    list *mSpanList

    // span第一个字节的地址，又名s.base()
    startAddr uintptr
    // span中页数目
    npages uintptr     

    // 在mSpanManual mspan中的空闲对象链表
    manualFreeList gclinkptr

    // freeindex 是从0到nelems之间的索引 在span中用来扫描下一个空闲的对象
    // 每次申请从freeindex开始扫描allocBits直到遇到0，用来指示一个空闲的对象
    // freeindex随后调整所以下次扫描开始于刚刚发现的空闲对象

    // 如果freeindex == nelem，这span没有空闲的对象

    // allocBits是span中对象的位图，如果n是大于freeindex并且allocBits[n/8] &amp; (1&lt;&lt;(n%8)) == 0
    // 该对象n是空闲的；否则，对象n已经被申请。
    // 开始于nelem的Bits还没有被定义，所以不能被引用。
    // 
    // 对象n开始于地址 n*elemsize + (start &lt;&lt; pageShift)
    freeindex uintptr

    // span中对象的数目
    nelems uintptr

    // 在freeindex中缓存allocBits，移动allocCache，使得最低位对应index的位。
    // allocCache 持有allocBits的补充，因此允许ctz(count trailing zero)直接使用它。
    // allocCache可能包含超越s.nelems的位；调用者必须忽视它。
    allocCache uint64

    // allocBits和gcmarkBits持有指向span标记和申请位的指针。这些指针是8字节对齐。
    // 由三块持有数据的区域
    // free: 不再访问的Dirty区域可以被重用
    // next: 持有下个GC循环使用到信息
    // current: 当前GC循环中使用的信息
    // previous: 上一个GC循环中使用的信息
    // 一个新的GC循环开始于finishsweep_m的调用。finishsweep_m将previous区域移到free
    // 区域，current区域移到previous区域，next区域移到current区域，
    // next区域将被填充，因为span请求内存为下一个GC循环保存gcmarkBits，并为新分配的
    // span保存allocBits

    // 指针运算是靠手工完成，取代数组为了避免在关键路径上进行边界检查。
    // 标记阶段将会释放旧的allocBits，同时设置allocBits为gcmarkBits。gcmarkBits
    // 被替换为一个新的零化内存。
    allocBits *gcBits
    gcmarkBits *gcBits

    // 标记代数
    // 当 sweepgen == h-&gt;sweepgen-2, span需要被标记
    // 当 sweepgen == h-&gt;sweepgen-1, span正在被标记
    // 当 sweepgen == h-&gt;sweepgen, span已经被标记和准备使用
    // 当 sweepgen == h-&gt;sweepgen+1, 在开始扫描之前缓存了span，现在仍然缓存，需要进行扫描
    // 当 sweepgen == h-&gt;sweepgen+3, span被扫描，接着缓存，仍然需要缓存
    // 每次GC之后，h-&gt;sweepgen增加2

    sweepgen uint32
    // 
    divMul uint16
    // 如果非零，elemsize是2的幂，&amp;它会得到对象分配基地址
    baseMask uint16
    // 已经分配的对象数目
    allocCount uint16
    // 类型级别和nosacn
    spanclass spanClass    

    // mspan是基于页面的
    // 当msapn处于heap free treap(空闲树堆)，状态为mSpanFree, 同时heapmap(s-&gt;start)等于span;
    // heapmap(s-&gt;stars+s-&gt;npages-1) == span。
    // 当mspan处于heap scav treap(scav树堆), 那么除了上述scavenged=true，在其他情况下，scavenged=false。
    //
    // 当一个mspan被申请时，状态等于mSpanInUse或者mSpanManual，heapmap(i)等于span 对于所有的s-&gt;start &lt;= i &lt; s-&gt;start+s-&gt;npages
    // 每个mspan都是在双向链表中，不是在mheap的busy链表中，就在其中一个mcentral的span链表中。

    // mspan代表着真实内存，拥有这些状态：mSpanInUser，mSpanManual或者mSpanFree。这些状态的变迁限制如下：
    // * span可能从空闲跃迁为in-use或者manual在任何GC阶段
    // * 在标记过程(gcpase == _GCoff)，span可能从in-use跃迁为free(作为标记的结果)，或者manual跃迁为free(作为栈被释放的结果)
    // * 在GC(gcphase != _GCoff), span 不能从in-use或者manual跃迁为free。因为并发GC可能读一个指针，然后查找它的span，span
    // 状态必须是单调不变的。
    // mSpanInUse 支持垃圾回收的堆申请
    // mSpanManual 手动管理的申请
    state mSpanState

    // 在申请之前是否需要零化
    needzero uint8
    // 除以elemsize - divMagic.shift
    divShift uint8
    // 除以elemsize - divMagic.shift2
    divShift2 uint8
    // span的页是否释放给回OS
    scavenged bool
    // sizeclass或者npages计算得到
    elemsize uintptr
    // span的结束数据
    limit uintptr
    // 守卫特殊队列
    speciallock mutex
    // 按偏移量排序的特殊记录的链表
    // specials *special

30 runtime.stackcache_clear(c *mcache)
    lock(&amp;stackpoolmu)    
    for order := uint8(0); order &lt; _NumStackOrders; order++ {
        x := c.stackcache[order].list
        for x.ptr() != nil {
            y := x.ptr().next
            stackpoolfree(x, order)
            x = y
        }
        c.stackcache[order].list = 0
        c.stackcache[order].size = 0
    }
    unlock(&amp;stackpoolmu)

31 runtime.stackpoolfree(x gclinkptr, order uint8)
    // 将栈x加入到空闲pool，调用时必须持有stackpoolmu
    s := spanOfUnchecked(uintptr(x))
    if s.state != mSpanManual {
        // msapn申请区域不是stack，throw
        throw(&quot;&quot;)
    }
    if s.manualFreeList.ptr() == nil {
        stackpool[order].insert(s)
    }
    x.ptr().next = s.manualFreeList
    s.manualFreeList = x
    s.allocCount--

    if gcphase == _GCoff &amp;&amp; s.allocCount == 0 {
        // Span是完全空闲，如果我们正在标记的话，立刻返回给heap。
        // 如果GC是活跃，我们推迟释放直到GC结尾，为了避免如下类型的场景
        // 1) GC开始，扫描一个SudoG但是还没有标记SudoG.elem指针
        // 2) 指向栈的指针被复制
        // 3) 旧的栈被释放
        // 4) 包含的span被标记为空闲
        // 5) GC尝试标记SudoG.elem指针。标记失败因为指针看起来在空闲span里面。
        // 
        stackpool[order].remove(s)
        s.manualFreeList = 0
        osStackFree(s)
        mheap_.freeManual(s, &amp;memstat.stacks_inuse)
    }


32 runtime (m *mheap) freeManual(s *mspan, stat *uint64)
    // freeManual 释放一个由allocManual申请的手工管理的span，stat必须等于在申请s时传给allocManual的stat。
    // 这只能当gcphase=_GCoff被调用。
    // freeManual必须在系统栈中被调用因为它需要heap锁。

    s.needzero = 1
    lock(&amp;h.lock)
    *stat -= uint64(s.npages &lt;&lt; _PageShift)
    memstat.heap_sys += uint64(s.npages &lt;&lt; _PageShift)
    h.freeSpanLocked(s, false, true)
    unlock(&amp;h.lock)

33 runtime (h *mheap) freeSpanLocked(s *mspan, acctinuse, acctidle bool)
    switch s.state {
    case mSpanManual:
        if s.allocCount != 0 {
            throw(&quot;&quot;)
        }
    case mSpanInUse:
        if s.allocCount != 0 || s.sweepgen != h.sweepgen {
            throw(&quot;&quot;)
        }
        // mheap减去mspan page
        h.pageInUse -= uint64(s.npages)

        arena, pageIdx, pageMask := pageIndexOf(s.base())
        arena.pageInuse[pageIdx] &amp;^= pageMask
    default:
        throw(&quot;&quot;)
    }

    if acctinuse {
        memstat.heap_inuse -= uint64(s.npages &lt;&lt; _PageShift)
    }
    if acctidle {
        memstat.heap_idle += uint64(s.npages &lt;&lt; _PageShift)
    }
    s.state = mSpanFree

    h.coalesce(s)

    h.free.insert(s)

34 runtime pageIndexOf(p uintptr) (arena *heapArena, pageIdx uintptr pageMask uint8)
    ai := arenaIndex(p)
    arena = mheap_.arenas[ai.l1()][ai.l2()]
    pageIdx = ((p / pageSize) / 8) % uintptr(len(arena.pageInUse))
    pageMask = byte(1 &lt;&lt; ((p / pageSize) % 8))


35 runtime.spanOfUnchecked(p uintptr) *mspan 
    // 先通过指针p找出p所属的arena index，然后再通过mheap_.arenas的映射关系找到响应的mspan
    //go:nosplit
    // spanOfUnchecked 等价于 spanOf，不过调用者必须确保指针p处于可申请的堆区域中。
    ai := arenaIndex(p)
    return mheap_.arens[ai.l1()][ai.l2()].spans[(p/pageSize)%pagesPerArena]

36 runtime.spanOf(p uintptr) *mspan
    // spanOf返回p所属的span。如果p不是指向heap arena或者没有span包含指针p，spanOf返回nil
    // 如果p不是指向已经申请的内存，有可能返回不包含p的non-nil的span。如果可能，调用者应该
    // 调用spanOfHeap或者明确地检查span边界。
    // 必须是nosplit因为调用者是nosplit

    // 这个函数看起来大，但是我们在arenaL1Bits上面使用大量的常量用来将它控制在预算之内。另外
    // 这里很多检查都是Go不论如何都是需要作的安全检查，所以生产代码非常短。
    ri := arenaIndex(p)
    if arenaL1Bits == 0 {
        if ri.l2() &gt;= uint(len(meahp_.arenas[0])) {
            return nil
        }
    } else {
        if ri.l1() &gt;= uint(len(mheap_.arenas)) {
            return nil
        }
    }

    l2 := mheap_.arenas[ri.l1()]
    if arenaL1Bits != 0 &amp;&amp; l2 == nil {
        return nil
    }

    ha := l2[ri.l2()]
    if ha == nil {
        return nil
    }

    return ha.spans[(p/pagesize)%pagesPerArena]


37 runtime.mheap
    //go:noinheap

    // heap本身就是&quot;free&quot;和&quot;scav&quot;树堆，但是其他的全局数据也在这里。
    // mheap不能是堆分配的因为它包含了不能堆分配的mSpanLists。

    // 锁只能在系统栈获取，否则g可能死锁如果栈扩展的时候持有锁。
    lock mutex
    // 空闲span
    free mTreap
    // 标记generation
    sweepgen uint32
    // 所有span被标记
    sweepdone uint32
    // 活跃sweepone调用次数
    sweepers uint32

    // allspans是所有创建过的mspans切片。每个mspan只出现一次。
    // allspans的内存手工管理，可以重新申请和随着heap增长移动
    // 
    // 通常，allspans由mheap_.lock保护，阻止并发访问和备份存储的释放
    // 在STW期间访问可能没有持有锁，但必须确保在访问期间不能发生申请
    allspans []*mspan

    // sweepSpans维护两个mspan栈，一个是标记在使用的mspan，另外一个
    // 未标记在使用的msapn。在每次GC期间有2种主要的角色。由于在每次GC循环中，
    // sweepgen增加2，这就意味标记的spans在sweepSpans[sweep/2%2]和未标记的
    // spans在sweepSpans[1-sweepgen/2%2]。标记从未标记的stack pop出来的span,
    // push 仍然in-use的spans入栈。同样地，分配一个正在使用的span会push到
    // 以标记的栈
    sweepSpans [2]gcSweepBuf

    // 这些参数表示从heap_live到页面扫描计数的一个线性函数。均衡的sweep
    // 系统给标记为黑色在当前heap_live通过将当前扫描计数保持在该线上面


    // 这条线的斜率为sweepPagesPerByte，通过一个基点(sweepHeapLiveBasis，pagesSweptBasis)
    // 在任何时间，系统位于(memstats.heap_live，pagesSwept)在这片空间。
    // 重要的是，这条直线穿过我们控制的一个点，而不是简单地从原点(0,0)开始，因为这样
    // 可以让我们在考虑当前进程的同时调整扫描速率。如果我们只是调整斜率，它会产生不连续
    // 债务如果有任何进展的话。

    // 统计中的spans页
    pagesInUse uint64
    // 这个循环中标记页面，原子更新
    pagesSwept uint64
    // pagesSwept 用来作为原始标记比率，原子更新
    pagesSweptBasis uint64
    // heap_live中的值用来作为原始标记比率
    sweepHeapLiveBasis uint64
    // 均衡的标记比率
    sweepPagesPerByte float64


    // 回收速率参数
    // 2个基础参数和回收比率平衡均衡的标记实现，基本区别是:
    // *回收关注RSS，估计为heapRetained()
    // *不是推送回收到GC，它被定步到一个基于时间的速率计算在gcPaceScavenger

    // scavengeRetainedGoal代表这我们的目标RSS
    // 所有的字段访问必须通过锁
    // 
    scavengeTimeBasis int64
    scavengeRetainedBasis uint64
    scavengeBytesPerNS float64
    scavengeRetainedGoal uint64
    scavengeGen uint64

    // 页回收状态
    // recaimIndex是在下一页allArens的页面索引用来回收，特别是
    // 它指向arena allArenas[i / pagePreArena]的page(i%pagesPerArena)
    // 如果它大于等于 1&lt;&lt;63，页面reclaimer已经做了扫描页面标记
    reclaimIndex uint64

    // reclaimCredit是用于额外页面扫描的备用信贷。由于页面reclaimer工作
    // 在大量的块中，他可能相比于请求回收更多。任何备用页面释放会回到
    // 信贷pool
    reclaimCredit uintptr

    // Malloc统计
    // 用于大对象申请的字节数
    largealloc uint64
    // 大对象申请的数目
    nlargealloc uint64
    // 用于大对象的空闲字节数 &gt;maxsmallsize
    largefree uint64
    // 空闲大对象数目
    nlargefree uint64
    // 空闲小对象数目
    nsmallfree [_NumSizeClassed]uint64

    // arenas是堆arena map。它指向整个可用虚拟地址空间的每个arena帧的堆元数据
    // 使用arenaIndex来计算在这个切片的index
    // 对于Go heap不支持的地址空间区域，arena map可能包含nil
    // 修改被mheap_.lock保护，执行读不需要锁；然而，一个给定
    // 实例在没有持有锁的情况下可以从nil过渡到non-nil。(实例从不
    // 过渡回来为nil)
    // 通常，这是一个2层映射由L1map和可能许多L2maps组成。当他们是大量arena栈时，这样节省空间。
    // 然而，在很多平台(即使是64-bit)，arenaL1Bits等于0，使这成为
    // 一个有效的简单等级的map。在这种场景下，arena[0]永远不会为nil
    arenas [1 &lt;&lt; arenaL1Bits]*[1 &lt;&lt; arenaL2Bits]*heapArena

    // heapArenaAlloc 是一个块用于申请heapArena对象的预保留。
    // 这只使用在32-bit上，我们预保留这块空间避免和堆本身交叉。
    heapArenAlloc linearAlloc

    // arenaHist是用来添加更多heap arenas的地址列表。它最初由一组通常提示地址填充，伴随这实际堆范围边界增长。
    arenaHints *arenaHint

    // arena 是一块用于申请heap arenas(真实arenas)的预保留空间，只是用在32-bits上。
    arena linearAlloc

    // allArenas 是每个映射arena的arenaIndex。它可以用来遍历地址空间
    // 访问由mheap_.lock保护，然而，由于只是追加和老的备份数组从不释放，获取mheap_.lock是安全的，复制切片头，然后释放mheap_.lock。
    allArenas []arenaIdx

    // sweepArenas 是发生在标记循环开始的allArenas快照。通过阻塞GC(或者机制抢占)可以安全地读。
    sweepArenas []arenaIdx

    // curArena 是heap正在增长的arena。它应该总是物理页对齐的。
    curArena struct {
        base, end uintptr
    }

    // central 空闲列表面对小类型对象
    // padding 确保mcentrals是以CacheLinePadSize字节分隔，所以每个mcentral.lock得到自己的cache line
    // central的索引是spanClass
    central [numSpanClass]struct {
        mcentral mcentral
        pad [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte
    }

    // span申请者
    spanalloc fixalloc
    // mcache申请者
    cachealloc fixalloc
    // treapNodes申请者
    treapalloc fixalloc
    // specialfinalizer申请者
    specialfinalizeralloc fixalloc
    // specialprofile申请者
    specialprofilealloc
    // special record 申请者的锁
    speciallock mutex
    // arenaHints 申请者
    arenaHintAlloc fixalloc

    // 从不设置，这里只是强制specailfinalizer类型为DWARF
    unused *specialfinalizer

38 runtime (h *mheap) coalesce(s *mspan)
    // 合并相邻mspan

    // merge 是一个帮助器用来将其他合并到s，删除heap元数据中对这些的引用，然后丢弃他们。这些mspan必须与s相邻
    merge := func(a, b, other *mspan) {
        // 调用者必须确保a.startAddr &lt; b.startAddr 和a或者b是s。a和b必须是相邻的。other是两者中不是s的一个。
        if pageSize &lt; physPageSize &amp;&amp; a.scavenged &amp;&amp; b.scavenged {
            // 如果我们在pageSize &lt; physPageSize的系统上合并2个回收的spans，他们的边界总是在物理页边界上，因为重组发生在合并过程。
            _, start := a.physPageBounds()
            end, _ := b.physPageBounds()
            if start != end {
                throw(&quot;&quot;)
            }
        }

        // 通过base和npages调整s，同时也是在heap 元数据中
        s.npages += other.npages
        s.needzero |= other.needzero
        if a == s {
            // s.base()+s.npages*pageSize-1是合并后mspan的尾地址
            h.setSpan(s.base()+s.npages*pageSize-1, s)
        } else {
            s.startAddr = other.startAddr
            h.setSpan(s.base(), s)
        }

        // 大小可能正在改变，所以treap需要删除相邻的对象，同时作为一个联合节点添加回去。
        // 从mheap_.free treap找到mspan所属的treap节点，并移除。 
        h.free.removeSpan(other)
        // 设置该mspan的状态为 mSpanDead
        other.state = mSpanDead
        h.spanalloc.free(unsafe.Pointer(other))
    }

    // realign 是一个帮助器用于收缩other和扩容s使得他们的边界在一个物理页边界上。    
    realign := func(a, b, other *mspan) {
        // 调用者必须确保a.startAddr &lt; b.startAddr同时a和b有它一个是s，a和b必须相邻。other是2者之中不是s那个。
        // 如果pageSize &gt;= physPageSize所以spans总是对齐物理页边界，所以只是退出。
        if pageSize &gt;= physPageSize {
            return
        }
        // 由于我们重新调整other，我们必须从treap移除它
        h.free.removeSpan(other)

        // Round的边界接近最接近物理页大小，接近已回收的span
        boundary := b.startAddr
        if a.scavenged {
            boundary &amp;^ = (physPageSize-1)
        } else {
            boundary = (boundary + physPageSize-1) &amp;^ (physPageSize -1)
        }
        a.npages = (boundary - a.startAddr)/pageSize
        b.npages = (b.startAddr + b.npages*pageSize-boundary) / pageSize
        b.startAddr = boundary

        h.setSpan(boundary-1, a)
        h.setSpan(boundary, b)

        h.free.insert(other)
    }

    hpMiddle := s.hugePages()

    // Coalesce with earlier, latesr spans
    var hpBefore uintptr
    // 获取s前个mpsan: before，检查before的状态
    if before := spanOf(s.base()-1); before != nil &amp;&amp; before.state == mSpanFree {
        // 如果s的回收状态==before的回收状态，则合并
        if s.scavenged == before.scavenged {
            hpBefore = before.hugePages()
            merge(before, s, before)
        } else {
        // 重新调整(重新调整s和befefore的边界)
            realign(before, s, before)
        }    
    }

    // 现在检查下个span(地址更大)是否空闲和是否可以合并
    var hpAfter uintptr
    if after := spanOf(s.base()+s.npages*pageSize); after != nil &amp;&amp; after.state == mSpanFree {
        // s.base+s.npages*pageSize 是属于下个mspan的
        if s.scavenged == after.scavenged {
            hpAfter = after.hugePages()
            merge(s, after, after)
        } else {
            realign(s, after, after)
        }
    }

    // 如果s还没有将page归还给os并且 hugePages数量更多
    if !s.scavenged &amp;&amp; s.hugePages() &gt; hpBefore+hpMiddle+hpAfter {
        // 如果s已经增长以致它可能包含更多的huge page相比它和它现在合并的邻近mspan，则标记整个地区作为huge-page-backable
        // 另外，在我们打碎huge pages(比如linux)的系统上，huge pages可能不支持s，因为它可能由许多底层的VMA组成。主要问题是
        // 它可能导致对由大页面支持的空闲内存数量的估计不足，从而无法确定清楚速率。

        // 
        sysHugePage(unsafe.Pointer(s.base(), s.npages*pageSize))
    }



39 runtime (s *mSpan) hugePages() uintptr 
    // physPageSize 是操作系统物理页字节大小，Mapping和unmapping操作都是
    // 在多重物理页上完成的。
    // physHugePageSize 是操作系统默认物理大页的字节大小，它的申请对于应用不是透明的
    // 它被猜测和验证是2的幂

    // 如果设置，这必须是由操作系统初始化代码(典型在osinit中)设置，在mallocinit字前。然而
    // 设置它是可选的，同时保留默认值总是安全的(尽管可能效率较低)

    // 由于physHugePageSize总是被猜测是2的幂，physHugePageSize 被定义为physHugePageSize == 
    // 1 &lt;&lt; physHugePageShift。physHugePageShift的目的是用来避免在性能关键函数上作划分。

    // hugePages 返回mspan所拥有的内存区域中的对齐物理页数量
    if physHugePageSize == 0 || s.npages &lt; physHugePageSize/pageSize {
        return 0
    }
    start := s.base()
    end := start + s.npages*PageSize
    if physHugePageSize &gt; pageSize {
        // start对齐physHugePageSize
        start = (start + physHugePageSize -1) &amp;^ (physHugePageSize -1)
        end &amp;^ = physHugePageSize -1
    }
    if start &lt; end {
        return (end -start) &gt;&gt; physHugePageShift
    }
    return 0


40 runtime stackfree(stk stack)
    // go:systemstack
    // stackfree释放stk上的n个字节stack申请。
    // stackfree必须运行在系统栈上因为它用P的资源和必须不能扩张stack

    // 获取当前goroutine
    gp := getg()
    v := unsafe.Pointer(stk.lo)
    // stack的大小
    n := stk.hi - stk.lo
    if n&amp;(n-1) != 0 {
        // 是否是2的幂
        throw(&quot;&quot;)
    }
    if stk.lo+n &lt; stk.hi {
        throw(&quot;&quot;)
    }
    fi stackDebug &gt;= 1 {
        println(&quot;stackfree&quot;, v, n)
        memclrNoHeapPointers(v, n)
    }
    if debug.efence != 0 || stackFromSystem != 0 {
        if debug.efence != 0 || stackFaultOnFree != 0 {
            sysFault(v, n)
        } else {
            sysFree(v, n, &amp;memstats.stacks_sys)
        }
        return
    }
    if msanenables {
        msanfree(v, n)
    }

    if n &lt; _FixedStack&lt;&lt;_NumStackOrders &amp;&amp; n &lt; _StackCacheSize {
        order := uint8(0)
        n2 := n
        for n2 &gt; _FixedStack {
            order++
            n2 &gt;&gt; 1
        }
        x := gclinkptr(v)
        c := gp.m.mcache
        if stackNoCache != 0 || c == nil || gp.m.preemptoff != &quot;&quot; {
            lock(&amp;stackpoolmu)
            // 该stack是在heap内申请
            stackpoolfree(x, order)
            unlock(&amp;stackpoolmu)
        } else {
            if c.stackcache[order].size &gt;= _StackCacheSize {
                // 该stack是在heap内申请
                stackcacherelease(c, order)
            }
            x.ptr().next = c.stackcache[order].list
            c.stackcache[order].list = x
            c.stackcache[order].size += n
        }
    } else {
        // 根据地址uintptr(v)获取该地址所属的mspan:s
        s := spanOfUnchecked(uintptr(v))
        // 如果mspan状态不是mSpanManual，则抛出
        if s.state != mSpanManual {
            throw()
        }
        if gcphase == _GCoff {
            // 如果我们正在sweeping，立即释放stack
            osStackFree(s)
            // 手动释放mspan:s
            mheap_.freeManual(s, &amp;memstats.stacks_inuse)
        } else {
            // 如果GC正在运行，我们不能将stack span返回给heap 因为它可能被当作a heap span重新使用。
            // 同时它的状态改变会和GC发生竞争。取而代之的是将它添加到large stack cache。
            log2npage := stacklog2(s.npages)
            lock(&amp;stackLarge.lock)
            stackLarge.free[log2npage].insert(s)
            unlock(&amp;stackLarge.lock)
        }    
    }

41 runtime stackcacherelease(c *mcache, order uint8)
    //go:systemstack

    if stackDebug &gt;= 1 {
        print(&quot;&quot;)
    }
    x := c.stackcache[order].list
    size := c.stackcache[order].size
    lock(&amp;stackpoolmu)
    for size &gt; _StackCacheSize/2 {
        y := x.ptr().next
        stackpoolfree(x, order)    
        x = y
        size -= _FixedStack &lt;&lt; order
    }
    unlock(&amp;stackpoolmu)
    c.stackcache[order].list = x
    c.stackcache[order].size = size

42 runtime.heapArena struct 
    // heapArena存储heap arena的数据单元。heapArenas储存在Go heap
    // 之外，可以通过mheap_.arenas 索引访问。
    // 它直接通过OS申请，所以理想情况下它应该是系统页的倍数。举例，避免添加小字段。

    // bitmap 存储在这个区域的words的指针/标量bitmap，适合heapBits类型可以访问它
    bitmap [heapArenaBitmapBytes]byte
    // spans映射这片区域的虚拟页ID到*mspan，对于申请的spans，它们的页映射span本身。
    // 对于空闲的span，只有最低位和最高位的页映射span本身。内部页映射到任意span。
    // 对于从来没有被申请的页面，spans入口为空 
    // 
    // 修改通过mheap.lock保护。不需要锁可以执行读操作，但是只能执行已知包含在使用或者
    // 栈的span的索引。这就意味着在确定这个地址是会否有效和在spans数组中查找之间肯定不是
    // 安全点。
    spans [pagePerArena]*mspan

    // pageInUse是一个指定那个spans处于mSpanInUse状态的bitmap。这个bitmap的索引是页号
    // 但只是bit对应到每个使用的span的第一页。
    pageInUse [pagePerArena/8]uint8

    // pageMarks 是一个指明那个spans拥有标记对象的bitmap，类似pageInUse,只是每个使用的
    // span的第一页与bit对应。

    // 在标记过程中，写是原子完成。读不是原子性和锁空闲的，因为他们只是在扫描期间发生。(因此和读从不竞争)
    // 这只是用来快速查找这整个span可以释放。
    // 
    pageMarks [pagePerArena/8]uint8

43 runtime mcommoninit(mp *m)
    // m初始化
    _g_ := getg()

    // g0 stack对于用户来说没有意义
    if _g_ != _g_.m.g0 {
        callers(1, mp.createstack[:])
    }

    lock(&amp;sched.lock)
    if sched.mnext+1 &lt; sched.mnext {
        throw(&quot;&quot;)
    }
    mp.id = sched.mnext
    sched.mnext++
    // 检查sched.maxmcount(msched允许的最大值)
    checkmcount()

    mp.fastrand[0] = 1597334677 * uint32(mp.id)
    mp.fastrand[1] = uint32(cputicks)
    // 检查mp.fastrand[0]和mp.fastrand[1]是否都为0
    if mp.fastrand[0]|mp.fastrand[1] == 0 {
        mp.fastrand[1] = 1
    }

    mpreinit(mp)

44 runtime mpreinit(mp *m)
    mp.gsignal = malg(32 * 1024)
    mp.gsignal.m = mp

45 runtime malg(stacksize int32) *g
    // 申请一个满足stacksize字节的栈的goroutine

    newg := new(g)
    if stacksize &gt;= 0 {
        stacksize = round2(_StackSystem+stacksize)
        systemstack(func() {
            newg.stack = stackalloc(uint32(stacksize))    
        })
        newg.stackguard0 = newg.stack.lo + _StackGuard
        newg.stackguard1 = ^uintptr(0)
    }

    return newg

46 runtime stackalloc(n uint32) stack 
    //go:systemstack

    // stackalloc 申请一个n字节stack
    // stackalloc必须运行在系统栈因为它用per-P的资源同时必须不能分割栈。
    // stackalloc必须在调用栈中执行，因此我们从不尝试扩展这个栈在代码stackalloc运行的期间
    // 如果会导致死锁

    thisg := getg()        
    if thisg != this.m.g0 {
        //不是运行在调度栈上
        throw(&quot;&quot;)
    }

    if n&amp;(n-1) != 0 {
        // 栈的大小n 不是2的幂
        thow(&quot;&quot;)
    }

    if stackDebug &gt;= 1 {
        print(&quot;&quot;)
    }

    if debug.efence != 0 || stackFromSystem != 0 {
        // n对齐physPageSize
        n = uint32(round(uintptr(n), physPageSize))    
        // 从系统申请内存地址，v是这块地址开始地址
        v := sysAlloc(uintptr(n), &amp;memstats.stacks_sys)
        if v == nil {
            throw(&quot;&quot;)
        }
        return stack{uintptr(v), uintptr(v)+uintptr(n)}
    }

    var v unsafe.Pointer
    if n &lt; _FixedStack&lt;&lt;_NumStackOrders &amp;&amp; n &lt; _StackCacheSize {
        // 小stack通过一个固定大小，空闲列表的申请器申请。如果我们需要一个更大的stack，我们
        // 依赖申请一个专用的span。

        order := uint8(0)
        n2 := n
        if n2 &gt; _FixedStack {
            order++
            n2 &gt;&gt;= 1
        }
        var x gclinkptr
        c := thisg.m.mcache
        if stackNoCache != 0 || c == nil || thisg.m.preemptoff != &quot;&quot; {
            // c == nil 可能发生在内部的退出系统调用或者procresize。只是从全局pool中
            // 获取一个栈。另外在GC期间不能访问stackcache，因此是并发刷新。    
            lock(&amp;stackpoolmu)
            x = stackpoolalloc(order)
            unlock(&amp;stackpoolmu)
        } else {
            x = c.ta
        }
    }

47 runtime sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer
    p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)        
    if err != nil {
        if err == _EACCES {
            print(&quot;&quot;)
            exit(2)
        }
        if err == _EAGAIN {
            print(&quot;&quot;)
            exit(2)
        }
        return nil    
    }
    mSysStatInc(sysStat, n)
    return p

48 runtime stackpoolalloc(order uint8) gclinkptr
    // 从空闲池中申请一个stack，调用时必须持有stackpoolmu
    list := &amp;stackpool[order]
    s := list.first
    if s == nil {
        // 无空闲stacks. 申请另一个有效的span
        s = mheap_.allocManual(_StackCacheSize&gt;&gt;_PageShift, &amp;memstat.stacks_inuse)
        if s == nil {
            throw(&quot;&quot;)
        }
        if s.allocCount != 0 {
            throw(&quot;&quot;)
        }
        if s.manualFreeList.ptr() != nil {
            throw(&quot;&quot;)
        }
        osStackAlloc(s)
        s.elemsize = _FixedStack &lt;&lt; order
        for i := uintptr(0); i &lt; _StackCacheSize; i += s.elemsize {
            x := gclinkptr(s.base()+i)
            x.ptr().next = s.manualFreeList
            s.manualFreeList = x
        } 
        list.insert(s)
    }

49 runtime (h *mheap) allocManual(npage uintptr, stat *uint64) *mspan
        // allocManual 申请一个手动管理的由npage页组成的span，如果申请失败allocManual返回nil
        // allocManual添加使用的字节到*stat，这是memstats in-use字段。不像在GC heap的申请，
        // 这个申请不会计入heap_inuse或者heap_sys
        // 如果span.needzero设置，返回的span中的memory可能不是零。
        // allocManual 必须在系统栈中调用因此它需要heap锁。
        lock(&amp;h.lock) 
        s := h.allocSpanLocked(npage, stat) </code></pre><p>i            if s != nil {<br>                s.state = mSpanManual<br>                s.manualFreeList = 0<br>                s.allocCount = 0<br>                s.spanclass = 0<br>                s.nelems = 0<br>                s.limit = s.base() + s.npages&lt;&lt;_PageShift<br>                // 手动管理的内存不计入heap_sys<br>                memstats.heap_sys -= uint64(s.npages &lt;&lt; _PageShift)<br>            }</p>
<pre><code>        unlock(&amp;h.lock)
        return s

50 runtime (h *mheap) allocSpanLocked(npage uintptr, stat *uint64) *mspan
        // 申请一个给定大小的span。h必须被锁
        // 返回的span已经在空闲结构中移除，但是它的状态依然是mSpanFree
        t := h.free.find(npage)    
        // 
        if t.valid() {
            goto HaveSpan
        }

        if !h.grow(npage) {
            return nil
        }
        t = h.free.find(npage)
        if t.valid() {
            goto HaveSpan
        }
        throw(&quot;grew heap, but no adequate free span found&quot;)

    HaveSpan:

51 runtime (h *mheap) grow(npage uintptr) bool
        // 尝试添加最少npage页内存到heap，返回是否成功
        ask := npage &lt;&lt; _PageShift
        // 对齐物理页
        nBase := round(h.curArena.base+ask, physPageSize)
        if nBase &gt; h.curArena.end {
            // 在当前的arena没有足够的空间。申请更多的arena空间。
            // 这可能会让当前arena不连续，所以我们必须请求完整ask

            av, size := h.sysAlloc(ask)
            if av == nil {
                print(&quot;&quot;)
                return false
            }    

            if uintptr(av) == h.curArena.end {

            }
        }

52 runtime (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr)
        //
        n = round(n, heapAreanaBytes)        

        // 首先，尝试预保留arena
        v = h.arena.alloc(n, heapAreanaBytes, &amp;memstats.heap_sys)
        if v != nil {
            size = n
            goto mapped
        }

        // 尝试在hint地址上扩张heap
        for h.arenaHints != nil {
            hint := h.arenaHints    
            p := hint.addr
            if hint.down {
                p -= n
            }
            if p+n &lt; p {
                v = nil
            } else if arenaIndex(p+n-1) &gt;= 1&lt;&lt;arenaBits {
                // 超过可访问的地址heap
                v = nil
            } else {
                // 系统预留
                v = sysReserve(unsafe.Pointer(p), n)
            }
            if p == uintptr(v) {
                // 成功，更新hint
                if !hint.down {
                    p+=n 
                }
                hint.addr = p
                size = n
                break
            }
            // 失败。丢弃这个hint和尝试下一个hint
        }

53 runtime (l *linearAlloc) alloc(size, align uintptr, sysStat *uint64) unsaft.Pointer
        // l.next对齐align
        p := round(l.next, align)
        if p+size &gt; l.end {
            return nil
        }

        l.next = p + size
        // pEnd 对齐physPageSize
        if pEnd := round(l.next-1, physPageSize); pEnd &gt; l.mapped {
            // 
            sysMap(unsafe.Pointer(l.mapped), pEnd-l.mapped, sysStat)
            sysUsed(unsafe.ponter(l.mapped), pEnd-l.mapped)    
            l.mapped = pEnd
        }
        return unsafe.Pointer(p)

54 runtime sysReserve(v unsafe.Pointer, n uintptr) unsafe.Pointer
        p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP__PRIVATE, -1, 0)
        if err != 0 {
            return nil
        }
        return p

43 runtime.newproc1(fn *funcval, argp *uint8, narg int32, callergp *g, callerpc uintptr)
    // 创建一个运行fn从argp开始拥有narg字节参数的协程。callerpc是创建它的go语句地址。
    // 新的g被放到等待运行的g队列中。
    _g_ := getg() //获取当前goroutine
    acquirem() // 

    _p_ := _g_.m.p.ptr() //返回PP指针
    newg := gfget(_p_)

44 runtime.gfget(_p_ *p) *g
    // 从g空闲列表中获取
    // 如果本地列表是空，则从全局列表中获取一批

    retry:
    if _p_.gFree.empty() &amp;&amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) {
        lock(&amp;sched.gFree.lock)
        //将一批空闲的Gs移到P
        if _p_.gFree.n &lt; 32 {
            //优先获取有栈的Gs，同时如果 sched.gFree.stack.head = gp.schedlink
            gp := sched.gFree.stack.pop()
            if gp == nil {
                //
                gp = sched.gFree.noStack.pop()    
                if gp == nil {
                    break
                }
            }
            sched.gFree.n--
            _p_.gFree.push(gp) //以入栈的方式将goroutine 连接起来
            _p_.gFree.n++ 
        }
        unlock(&amp;sched.gFree.lock)
        goto retry
    }

    gp := _p_.gFree.pop() //弹出最后进栈的goroutine
    if gp == nil {
        return nil
    }

    _p_.gFree.n--
    if gp.stack.lo == 0 {
        // stack 已经在 gfput 中回收，重新申请一个新的
        systemstack(func() {
            gp.stack = stackalloc(_fixedStack)    
        })
        gp.stackguard0 = gp.stack.lo + _StackGurad    
    } else {
        if raceenabled {
            racemalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)
        }
        if msanenabled {
            msanmalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)
        }    
    }

    return gp

45 runtime.stackalloc(n uint32) stack
    // 申请b个自己的栈
    // stackalloc必须运行在系统栈上面因为它用每个P的资源，并且不能缩放堆栈。
    // Stackalloc必须运行在scheduler栈，因为我们从不尝试在stackalloc运行的代码期间
    // 增加堆栈 </code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><pre><code>https://docs.oracle.com/cd/E19205-01/820-1200/blaoy/index.html
https://blog.csdn.net/u010853261/article/details/103359762
https://me.csdn.net/u010853261    </code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/slice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/slice/" itemprop="url">slice</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-09T23:17:54+08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Slice-学习"><a href="#Slice-学习" class="headerlink" title="Slice 学习"></a>Slice 学习</h1><h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><pre><code>本文是我学习slice的一点心得。</code></pre><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><pre><code>从Go程序反汇编分析Slice

GO:
`
package main
import &quot;fmt&quot;
func main() {
    res := make([]int, 0)
    fmt.Println(&quot;length:&quot;, len(res))
    res = append(res, 1)
    res = append(res, 2)
    res = append(res, 3)
    fmt.Println(&quot;length:&quot;, len(res))
}    
`

反汇编： go tool objdump -S src &gt; app.s

ASM: (主要代码)
`
LEAQ 0x40(SP), AX
MOVQ AX, 0x80(SP)
MOVQ $0x0, 0x88(SP)
MOVQ $0x0, 0x90(SP)
...
MOVQ 0x90(SP), AX
MOVQ 0x88(SP), CX
MOVQ 0x80(SP), DX
LEAQ 0x1(CX), BX
CMPQ AX, BX
JG
...
LEAQ 0x1068d(IP), SI
MOVQ SI, 0(SP)
MOVQ DX, 0x8(SP)
MOVQ CX, 0x10(SP)
MOVQ AX, 0x18(SP)
MOVQ BX, 0x20(SP)
CALL runtime.growslice(SB)
`    </code></pre><h3 id="Golang代码"><a href="#Golang代码" class="headerlink" title="Golang代码"></a>Golang代码</h3><pre><code>CALL runtime.growslice(SB)
`
func growslice(et *_type, old slice, cap int) slice {
    //前面是否允许竞争检查
    newcap := old.cap
    doublecap := newcap + newcap
    if cap &gt; doublecap {
        newcap = cap 
    } else {
        if old.len &lt; 1024 {
            newcap = doublecap //2倍原来的cap
        } else {
            // Check 0 &lt; newcap to detect overflow
            // and prevent an infinite loop.
            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
                newcap += newcap / 4 // 4/1倍增长
            }
            // Set newcap to the requested cap when
            // the newcap calculation overflowed.
            if newcap &lt;= 0 {
                newcap = cap
            }
        }
    }

    capmem = roundupsize(uintptr(newcap)) //根据类型大小返回内存块大小
    ...
    p = mallocgc(capmem, nil, false) //需要切换都g0协程上申请空间
        ...
        mp := acquirem() //获取当前工作线程
        ...
        c := gomcache() //返回当前个工作线程的cache(缓存)
        ...
        if size &lt;= maxSmallSize(32768) {
            if noscan &amp;&amp; size &lt; maxTinySize(16) {
                // Tiny allocator, be noscan (don&apos;t have pointers)
                ...
                if off+size &lt;= maxTinySize &amp;&amp; c.tiny != 0 {
                    x = unsafe.Pointer(c.tiny + off)
                    releasem(mp)
                    ...
                    return x
                }
                // Allocate a new maxTinySize block. //申请一个新的maxTinySize（16bytes）的内存块

            } else {
                ...
                v := nextFreeFast(span)
                ...
                if v == 0 {
                    v, span, shouldhelpgc = c.nextFree(spc)
                }
                ...
                if needzero &amp;&amp; span.needzero != 0 {
                    memclrNoHeapPointers(unsafe.Pointer(v), size) //是由汇编实现
                }
            }
        else {
            systemstack(func() {
                s = largeAlloc(size, needzero, noscan)
            })    //systemstack 由汇编实现，切换到
        }    
    }

func mstart() {

}

`</code></pre><h3 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h3><pre><code>TEXT runtime·systemstack(SB), NOSPLIT, $0-8    //无函数栈，1个参数无返回值
    MOVQ    fn+0(FP), DI    // DI = fn，将第一个参数放在DI寄存器
    get_tls(CX) // get_tls 是宏，获取当前协程
    MOVQ    g(CX), AX       // AX = g，将g存在AX寄存器
    MOVQ    g_m(AX), BX     // BX = m，将工作线程存在BX寄存器
    CMPQ    AX, m_gsignal(BX) //当前工作线程的gsignal是当前协程
    JEQ     noswitch //相等无需切换

    MOVQ    m_g0(BX), DX    // DX = g0，获取g0的协程
    CMPQ    AX, DX  //相等无需切换
    JEQ     noswitch

    // switch stacks
    // save our state in g-&gt;sched. Pretend to
    // be systemstack_switch if the G stack is scanned.
    MOVQ    $runtime·systemstack_switch(SB), SI
    MOVQ    SI, (g_sched+gobuf_pc)(AX) //暂存状态
    MOVQ    SP, (g_sched+gobuf_sp)(AX)
    MOVQ    AX, (g_sched+gobuf_g)(AX)
    MOVQ    BP, (g_sched+gobuf_bp)(AX)

     // switch to g0
    MOVQ    DX, g(CX)
    MOVQ    (g_sched+gobuf_sp)(DX), BX
    // make it look like mstart called systemstack on g0, to stop traceback
    SUBQ    $8, BX
    MOVQ    $runtime·mstart(SB), DX
    MOVQ    DX, 0(BX)
    MOVQ    BX, SP

    // call target function
    MOVQ    DI, DX
    MOVQ    0(DI), DI
    CALL    DI   

    // switch back to g
    get_tls(CX)
    MOVQ    g(CX), AX
    MOVQ    g_m(AX), BX
    MOVQ    m_curg(BX), AX
    MOVQ    AX, g(CX)
    MOVQ    (g_sched+gobuf_sp)(AX), SP
    MOVQ    $0, (g_sched+gobuf_sp)(AX)
    RET

    noswitch:
    // already on m stack; tail call the function
    // Using a tail call here cleans up tracebacks since we won&apos;t stop
    // at an intermediate systemstack.
    MOVQ    DI, DX
    MOVQ    0(DI), DI
    JMP     DI</code></pre><p>bad:<br>        // Bad: g is not gsignal, not g0, not curg. What is it?<br>        MOVQ    $runtime·badsystemstack(SB), AX<br>        CALL    AX<br>        INT     $3</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/JerryZhou/golang-doc" target="_blank" rel="noopener">https://github.com/JerryZhou/golang-doc</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/Go%E6%B1%87%E7%BC%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/Go%E6%B1%87%E7%BC%96/" itemprop="url">Go汇编</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-09T23:17:47+08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Golang汇编学习"><a href="#Golang汇编学习" class="headerlink" title="Golang汇编学习"></a>Golang汇编学习</h1><h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>本文是我学习Go汇编的一点心得</p>
<h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><pre><code>1.）算法加速，golang编译器生成的机器码基本上都是通用代码，优化程度一般，我们需要用到特殊优化逻辑、特殊的CPU指令让我们的算法运行速度更快。https://github.com/minio/sha256-simd
2.）摆脱golang编译器一些约束，如通过汇编调用其他package的私有函数。https://sitano.github.io/2016/04/28/golang-private/
3.）进行一些hack的事，通过汇编适配其他语言的ABI来直接调用其他语言的函数。 https://github.com/petermattis/fastcgo
4.）利用 //go:noescape 进行内存分配优化，golang编译器拥有逃逸分析，用于决定每一个变量是分配在堆内存、还是函数栈。https://github.com/golang/go/blob/d1fa58719e171afedfbcdf3646ee574afc08086c/src/reflect/value.go#L2585-L2597</code></pre><h4 id="Go几个虚拟寄存器"><a href="#Go几个虚拟寄存器" class="headerlink" title="Go几个虚拟寄存器"></a>Go几个虚拟寄存器</h4><h4 id="栈调整"><a href="#栈调整" class="headerlink" title="栈调整"></a>栈调整</h4><pre><code>栈的调整是通过对硬件SP寄存器进行运行来实现。
如：
SUBQ $0x18, SP //为函数分配函数栈帧
ADDQ $0x18, SP //对SP做加法，清除函数栈帧</code></pre><h4 id="数据搬运"><a href="#数据搬运" class="headerlink" title="数据搬运"></a>数据搬运</h4><pre><code>常数在plan9汇编用$num表示，可以为负数，默认情况下为十进制。搬运的长度是有MOV后缀决定的。
MOVB $1,DI // 1 byte
MOVW $0x10, BX // 2bytes
MOVD $1, DX // 4bytes
MOVQ $-10, AX // 8bytes</code></pre><h4 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h4><h5 id="section跳转"><a href="#section跳转" class="headerlink" title="section跳转"></a>section跳转</h5><pre><code>JMP addr //跳转到地址，地址可为代码中地址
JMP label //跳转到标签，可以跳转到同一函数内的标签位置
JMP 2(PC) //以当前指令为基础，向前/向后跳转X行
JMP -2(PC) //同上
JNZ target //如果zero flag被set过，则跳转</code></pre><h5 id="函数调用跳转"><a href="#函数调用跳转" class="headerlink" title="函数调用跳转"></a>函数调用跳转</h5><pre><code>JMQ SP/BP 不会发生变化，栈空间不会发生变化。
CALL 栈空间会发生响应的变化，传递参数时，我们需要输入参数，返回值按之前将栈的布局安排在调用者的栈顶，然后在调用CALL函数来调用其函数，
调用CALL命令后，SP寄存器会下移一个WORD，然后进入新函数的栈空间执行。</code></pre><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><pre><code>参考源代码arch 部分：https://github.com/golang/arch/blob/master/x86/x86.csv</code></pre><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><pre><code>rax -&gt; AX
rbx -&gt; BX
rcx -&gt; CX
rdx -&gt; DX
rdi -&gt; DI
rsi -&gt; SI
r8 ~ r15 -&gt; R8 ~ R15
RBP -&gt; bp
RSP -&gt; sp

bp和sp用来管理栈顶和栈底，最好不要拿来运算。plan9中使用寄存器不需要带r或者e的前缀，例如rax，只要写成AX即可。</code></pre><h4 id="伪寄存器"><a href="#伪寄存器" class="headerlink" title="伪寄存器"></a>伪寄存器</h4><pre><code>GO汇编引入4个伪寄存器。
FP: Frame poniter: arguments and locals
PC: Program counter: jumps and branches
SB: Static base pointer: global symbols
SP: Stack pointer: top of stack

FP: 使用形如symbol+offset（FP）的方式，引用函数的输入参数。例如args0+0(FP)
PC: 就是体系结构中的PC寄存器
SB: 全局静态基指针，一般用来声明函数或者全局变量。
SP: 指向当前栈帧的局部变量的开始位置。使用形如symbol+offset(SP)方式，引用函数局部变量。offset的取值范围：[-framesize,0)

go tool objdump/go tool compile -S 输出的代码是没有伪SP和FP寄存器的。在汇编结果中，只有真实的SP寄存器。
其实伪寄存器FP和SP相当于plan9伪汇编中的一个助记符，他们是根据当前函数栈空间计算出来的一个相对于物理寄存器SP的一个偏移量坐标。当在一个函数中，如果用户手动修改了物理寄存器SP的偏移，则伪寄存器FP和SP也随之发生对应的偏移。</code></pre><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><pre><code>在汇编所谓的变量，一般是存储在 .rodata或者 .data段中的只读值。对应到应用层的话，就是已初始化的全局的const，var，statics常量/变量。
使用DATA结合GLOBL来定义一个变量。DATA用法如下：
DATA symbol+offset(SB)/width, value

offset的函数是该值相对于符号symbol的偏移，而不是相对于全局某个地址的偏移。
使用GLOBL指令来将变量声明为global，额外接收2个参数，一个是flag，另外一个是变量的总大小。
GLOBL divtab(SB), RODATA, $64

定义数据，或字符串，这是需要用到非0的offset，例如：
DATA bio&lt;&gt;+0(SB)/8, $&quot;oh yes i&quot;
DATA bio&lt;&gt;+8(SB)/8, $&quot;am here&quot;
GLOBL bio&lt;&gt;(SB), RODATA, $16

go编译器为了方便汇编访问struct的指定字段，会在编译过程中自动生成一个go_asm.h文件，可以通过#include &quot;go_asm.h&quot; 语言来引用，该文件中会生成该包内全部struct的每个字段的偏移量宏定义与结构体大小到的宏定义。

我们可以通过命令go tool compile -S -asmhdr dump.h *.go来导出相关文件编译过程中会生成的宏定义</code></pre><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><pre><code>在plan9中TEXT是一个指令，用来定义一个函数。    

TEXT package·add(SB),NOSPLIT,$32-32
         |     |                | |
         包名  函数名           栈帧大小 参数及返回值大小

 当有NOSPLIT表示时，可以不写输入参数，返回值占用的大小（这时会强行插入CALLER BP）</code></pre><h5 id="调用其他函数"><a href="#调用其他函数" class="headerlink" title="调用其他函数"></a>调用其他函数</h5><pre><code>在汇编中调用其他函数通常是：
JMP： 直接跳转时，与函数栈空间相关的几个寄存器SP/FP不会发生变化，可以理解为被调用者复用调用者的栈空间。此时，参数传递采用寄存器传递，调用者和
    被调用者协商好使用那些寄存器传递参数，调用者将参数写入这些寄存器，然后跳转到被调用者，被调用者从相关寄存器读出相关参数。

CALL: 通过CALL命令来调用其他函数时，占空间会发生响应变化（寄存器SP/FP随之发生变化）。传递参数时，我们需要输入参数、返回值按之前将的栈布局安排在调用者的栈顶
（低地址），然后在调用CALL命令来调用其他函数，调用CALL命令后，SP寄存区会下移一个WORD，然后进入新函数的栈空间运行。return addr（函数返回地址）不需要用户维护，CALL
指令会自动维护。</code></pre><h5 id="回调函数-闭包"><a href="#回调函数-闭包" class="headerlink" title="回调函数/闭包"></a>回调函数/闭包</h5><pre><code>当函数参数中包含回调函数时，回调函数的指针通过一种简介方式传入，之所以采用这种设计也是为例照顾闭包调用的实现。在Golang的ABI中，关于回调函数、闭包的
上下文由调用者来维护，被调用者按照规定的格式来使用。    

1.调用者需要申请一段临时内存区域来存储函数指针，当传递参数是闭包时，该临时内存区域开可以进行扩充，用于存储闭包中捕获的变量，通常编译器将该内存区域定义成结构体：
struct { f uintptr; a *int}的结构。该临时内存区域可以分配在栈上，也可以分配在堆上，也可以分配到寄存器上，到底分配到那里，需要编译器根据逃逸分析的结果来决定。
2.将临时内存区域的地址存储于对应 被调用函数 入参的对应位置上；其他参数按照上面常规方法放置。
3.使用CALL执行调用 被调用函数（callee-call）
4.在被调用函数（callee-call） 中从对应参数位置中去除临时内存区域的指针存储在指定寄存器DX(仅限于AMD64平台)
5.然后从DX指向的临时内存区域的首部取出函数指针，存储于AX
6.然后在执行CALL AX指令来调用传入的回调函数。
7.当回调函数是闭包时，需要使用捕获的变量时，直接通过寄存器DX加对应偏移量来获取。
8.示例:

  Go
      `
  package main
  import &quot;fmt&quot;
  func fun1()
  func fcall(uintptr, int)
  func Test()
  func Goprint(n int) {
        fmt.Println(&quot;n:&quot;, n)
  }
  func main() {
            Test()
  }

  `
  Asm
  `
  #include &quot;textflag.h&quot;

  TEXT ·fun1(SB), NOSPLIT|NEEDCTXT, $16-0
    MOVQ 8(DX), AX
    INCQ (AX)
    MOVQ (AX), BX
    MOVQ BX, arg-16(SP)
    CALL ·Goprint(SB)
    RET

  TEXT ·fcall(SB), NOSPLIT, $16-16
    MOVQ fn+8(FP), BX
    MOVQ BX, arg-16(SP)
    CALL ·Goprint(SB)
    MOVQ fn+0(FP), DX
    MOVQ (DX), AX
    CALL AX
    RET

  TEXT ·Test(SB), NOSPLIT, $48-0
    MOVQ $0, n-32(SP)
    LEAQ n-32(SP), AX
    MOVQ AX, n_adr-8(SP)
    LEAQ ·fun1(SB), AX
    MOVQ AX, fn-16(SP)
    LEAQ fn-16(SP), AX
    MOVQ $1, n1-40(SP)
    MOVQ AX, fn-48(SP)
    CALL ·fcall(SB)
    RET

  `</code></pre><h5 id="直接调用C函数（FFI）"><a href="#直接调用C函数（FFI）" class="headerlink" title="直接调用C函数（FFI）"></a>直接调用C函数（FFI）</h5><pre><code>在GO中调用C函数存在巨大的额外开销。可以考虑绕开CGO机制，直接调用C函数，就要遵循C的ABI    
amd64 c ABI
在调用C函数时，主流有2种ABI。
Windows x64 c and c++ ABI 主要适用于各windows平台
System V ABI 主要适用于Solaris, Linux, FreeBSD, MacOS等

在ABI规定中，参数传递的协议:
当参数都是整数且少于7个时，参数从左到右放入寄存器：rdi, rsi, rdx, rcx, r8, r9
当参数都是整数而多于或者等于7个时，前6个还是与前面一样，但后面的依次从右向左放入栈中，即和32位汇编一样。

由于该issue(https://github.com/golang/go/issues/20427#issuecomment-343255844)的存在，通常goroutine的栈空间很小，很可能产生栈溢出的错误。解决的方法有：
    1.直接切换到g0栈，g0栈是系统原生线程的栈，通常比较大而且与C兼容性更好，切换g0栈方法可以参考（https://github.com/petermattis/fastcgo）的实现，但是有强烈的版本
    依赖。
    2.调用函数自身声明一个很大的栈空间，迫使goroutine栈扩张。具体参考方法rustgo(https://blog.filippo.io/rustgo/)，该方法不能确定每一个C函数具体的栈空间需求，只能
    根据猜测分配一个足够大的，同时也会造成比较大的浪费。
    3.使用runtime·systemstack切换到g0栈，同时摆脱了版本依赖。具体方法可以参考numa(https://github.com/lrita/numa/blob/2073a6660808a7b8d0fec85013b0301327439d97/numa_linux_amd64.s#L49-L59)</code></pre><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><h4 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h4><pre><code>    ---------------------------------
    current func arg0
    --------------------------------- &lt;-------FP (pseudo FP)
    caller ret addr
---    --------------------------------- high address
 |    caller BP(*)
 |    --------------------------------- &lt;-------SP (pseudo SP, 实际上是当前栈帧的BP位置)
 |    local var0
 |    ---------------------------------
 |    local var1
 |    ---------------------------------
 s    local var2
 t    ---------------------------------
 a    .........
 c    ---------------------------------
 k    local varN
     ---------------------------------
 f    temporarilly
 r    unused space
 a    ---------------------------------
 m    call retn 调用函数第n个返回值
 e    --------------------------------
    call ret(n-1) 调用函数第n-1个返回值
 |    --------------------------------
 |    ..............
 |    --------------------------------
 |    call ret1 调用函数第1个返回值
 |    --------------------------------
 |    call argn 调用函数第n个参数
 |    --------------------------------
 |    .....................
 |    --------------------------------
 |    call arg1 调用函数第一个参数
 |    -------------------------------- &lt;--------- 硬件SP位置
 |    return addr 返回值地址
---    -------------------------------- low address

    栈是朝低地址方向增长的。</code></pre><h5 id="argsize和framesize计算规则"><a href="#argsize和framesize计算规则" class="headerlink" title="argsize和framesize计算规则"></a>argsize和framesize计算规则</h5><pre><code>如函数申明：TEXT package·add(SB),NOSPLIT,$16-32
argsize:caller（存储）
framesize:callee（存储）
`$16-32表示 $framesize-argsize。Go在函数调用时，参数和返回值都需要由caller再起栈帧上备好空间`。argsize计算方法是：参数大小求和+返回值大小求和。如入参是3个int64类型，返回值是1个int64类型，那么这里的argsize=sizeof(int64) * 4。
return address(rip)的值也是存储在caller的stack frame上的，但是这个过程是由CALL指令和RET指令完成PC寄存器的保存和恢复。    </code></pre><h5 id="地址运算"><a href="#地址运算" class="headerlink" title="地址运算"></a>地址运算</h5><pre><code>地址运算也是用LEA 指令，英文愿意为 Load Effective Addresss，amd64平台地址都是8个字节，所有直接就用LEAQ就好。
例子： LEAQ (BX)(AX*1), CX

MOVQ命令，在寄存器加偏移的情况下MOVQ会对地址进行解引用。
MOVQ (AX), BX   // =&gt; BX = *AX 将AX指向的内存区域8byte赋值给BX
MOVQ AX, BX     // =&gt; BX = AX 将AX中存储的内容赋值给BX，注意区别</code></pre><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre><code>math.go
`
package main
import &quot;fmt&quot;
func add(a, b int)int //汇编声明
func main() {
    fmt.Println(add(10,11))
}
`


math.s
`
#include &quot;textflag.h&quot;

TEXT .add(SB), NOSPLIT, $0-24
    MOVQ a+0(FP), AX
    MOVQ b+8(FP), BX
    ADDQ BX, AX
    MOVQ AX, ret+16(FP)
    RET
`

把两个文件放在任意目录下，执行go build并运行就可以看到效果</code></pre><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h6><pre><code>标准库的数值类型：
1.int/int8/int16/int32/int64
2.uint/uint8/uint16/uint32/uint64
3.float32/float64
4.byte/rune
5.uintpr

这些类型在汇编中就是一段储存着数据的连续内存，只是内存长度不一样，操作的时候看好数据长度就行。

1.struct
struct在汇编层面实际上就是一段连续内存，在作为参数传给函数时，会将其展开在caller的栈上传给对应的callee:</code></pre><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><pre><code>汇编命令：go tool compile -l -N -S
反汇编命令：go tool objdump -S</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><pre><code>https://www.altoros.com/blog/golang-internals-part-1-main-concepts-and-project-structure/
https://github.com/yangyuqian/technical-articles/blob/master/asm/golang-plan9-assembly-cn.md
https://xargin.com/plan9-assembly/
https://www.cnblogs.com/landv/p/11589074.html
https://quasilyte.dev/blog/post/go-asm-complementary-reference/#external-resources
https://www.cnblogs.com/landv/p/11589074.html
http://blog.studygolang.com/2013/05/asm_and_plan9_asm/
https://zhuanlan.zhihu.com/p/56750445?utm_campaign=studygolang.com&amp;utm_medium=studygolang.com&amp;utm_source=studygolang.com
https://lrita.github.io/2017/12/12/golang-asm/#why
https://blog.gopheracademy.com/advent-2016/peachpy/
https://sitano.github.io/2016/04/28/golang-private/
https://syslog.ravelin.com/anatomy-of-a-function-call-in-go-f6fc81b80ecc
https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/lex.go#L52
https://golang.org/cmd/compile/#hdr-Compiler_Directiveshttps://golang.org/cmd/compile/#hdr-Compiler_Directives
https://segmentfault.com/a/1190000016354799#articleHeader2
https://segmentfault.com/a/1190000016743220
https://github.com/sxs2473/go-performane-tuning
https://github.com/JerryZhou/golang-doc/blob/master/Golang-Internals/Part-6.Bootstrapping.and.Memory.Allocator.Initialization.md</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
